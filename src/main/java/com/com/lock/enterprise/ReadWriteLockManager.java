/*
 * Copyright 2017 BeUndead
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.com.lock.enterprise;

import java.util.Objects;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * Extension of {@link LockManager} which additionally provides separate semantics for the acquisition and release of
 * {@linkplain java.util.concurrent.locks.ReadWriteLock read/write locks}.
 * <p>
 * If {@link IllegalStateException} is thrown by any of the methods in this class; subsequent interactions are
 * undefined.  This should not occur.
 *
 * @param <K> The type of the {@code keys} used for referring to locks.
 */
public interface ReadWriteLockManager<K> extends LockManager<K> {

    /**
     * {@inheritDoc}
     * <p>
     * Implementation acquires a {@linkplain #writeLock(Object, long, TimeUnit) write lock}.
     */
    @Override
    default TypedLockToken lock(final K key, final long timeout, final TimeUnit unit)
            throws IllegalArgumentException, InterruptedException, TimeoutException {
        return this.writeLock(key, timeout, unit);
    }

    /**
     * {@inheritDoc}
     * <p>
     * Implementation will release <strong>both</strong> {@linkplain #writeLock(Object, long, TimeUnit) write locks} and
     * {@linkplain #readLock(Object, long, TimeUnit) read locks} depending on the provided
     * {@linkplain LockToken providedToken}.
     */
    @Override
    default void unlock(final K key, final LockToken providedToken)
            throws IllegalArgumentException, IllegalMonitorStateException {
        if (key == null) throw new IllegalArgumentException("'key' must not be 'null'");
        if (providedToken == null) throw new IllegalArgumentException("'providedToken' must not be 'null'");
        if (!(providedToken instanceof TypedLockToken)) {
            throw new IllegalArgumentException("'providedToken' was not generated by this class");
        }

        final TypedLockToken token = (TypedLockToken) providedToken;
        switch (token.getLockType()) {
            case Read:
                this.unlockReadLock(key, token);
                break;
            case Write:
                this.unlockWriteLock(key, token);
                break;
            default:
                throw new IllegalArgumentException(
                        String.format("Unknown LockType for providedToken: '%s'", Objects.toString(token.getLockType())));
        }
    }

    /**
     * Acquires a <strong>read lock</strong> for the given {@code key}.
     * <p>
     * It is expected that any number of read locks can be concurrently held; but a read lock may not be held while any
     * write lock is held.
     *
     * @param key     The {@code key}, used to reference <strong>which</strong> lock to acquire.  Must not be {@code
     *                null}.
     * @param timeout The timeout (in {@link TimeUnit unit units}) to allow waiting for the lock acquisition to succeed.
     *                Must not be negative.
     * @param unit    The {@link TimeUnit unit} which the provided {@code timeout} is provided.  Must not be {@code
     *                null}.
     *
     * @return A {@link TypedLockToken} (which should be used in a subsequent call to
     *         {@link #unlock(Object, LockToken)}) indicating that lock acquisition was successful.
     *
     * @throws IllegalArgumentException If any of the arguments are invalid.
     * @throws InterruptedException     If the executing {@link Thread} is {@linkplain Thread#interrupt() interrupted}
     *                                  whilst awaiting the acquisition of the lock.
     * @throws TimeoutException         If lock acquisition was not successful within the provided {@code timeout}.
     */
    TypedLockToken readLock(K key, long timeout, TimeUnit unit)
            throws IllegalArgumentException, InterruptedException, TimeoutException;

    /**
     * Performs the unlock of an {@linkplain #readLock(Object, long, TimeUnit) acquired read lock}.
     * <p>
     * It is expected that the provided {@code token} will be the <strong>same</strong> as that returned when
     * {@linkplain #readLock(Object, long, TimeUnit) acquiring the lock}.
     *
     * @param key   The {@code key}, used to reference <strong>which</strong> lock should be unlocked.  Must not be
     *              {@code null}.
     * @param token The {@link LockToken} which was returned when acquiring the lock.
     *
     * @throws IllegalArgumentException     If any of the arguments are invalid.
     * @throws IllegalMonitorStateException If a lock is not held for the given {@code key} and {@link TypedLockToken}.
     */
    void unlockReadLock(K key, TypedLockToken token)
            throws IllegalArgumentException, IllegalMonitorStateException;

    /**
     * Converts the presently held lock (indicated by the provided {@link TypedLockToken}) to a write lock.  The
     * existing lock will be consistently held during this call.
     * <p>
     * It is safe to call this method with a {@code token} for an already acquired write lock.  The provided {@code
     * token} should be disregarded in favour of the returned {@link TypedLockToken} from this call.
     *
     * @param key   The {@code key}, used to reference <strong>which</strong> lock should be converted.  Must not be
     *              {@code null}.
     * @param token The {@link LockToken} which was returned when acquiring the lock.
     *
     * @return A {@link TypedLockToken} indicating successful lock conversion.
     *
     * @throws IllegalArgumentException          If any of the arguments are invalid.
     * @throws IllegalMonitorStateException      If a lock is not held for the given {@code key} and
     *                                           {@link TypedLockToken}.
     * @throws FailedLockTypeConversionException If the lock type conversion failed (the original lock will still be
     *                                           held).
     */
    TypedLockToken convertToWriteLock(K key, TypedLockToken token)
            throws IllegalArgumentException, IllegalMonitorStateException,
                   FailedLockTypeConversionException;

    /**
     * Acquires a <strong>write lock</strong> for the given {@code key}.
     * <p>
     * It is expected that only a single write lock can be held concurrently and that no concurrent read locks will
     * also be held.
     *
     * @param key     The {@code key}, used to reference <strong>which</strong> lock to acquire.  Must not be {@code
     *                null}.
     * @param timeout The timeout (in {@link TimeUnit unit units}) to allow waiting for the lock acquisition to succeed.
     *                Must not be negative.
     * @param unit    The {@link TimeUnit unit} which the provided {@code timeout} is provided.  Must not be {@code
     *                null}.
     *
     * @return A {@link TypedLockToken} (which should be used in a subsequent call to
     *         {@link #unlock(Object, LockToken)}) indicating that lock acquisition was successful.
     *
     * @throws IllegalArgumentException If any of the arguments are invalid.
     * @throws InterruptedException     If the executing {@link Thread} is {@linkplain Thread#interrupt() interrupted}
     *                                  whilst awaiting the acquisition of the lock.
     * @throws TimeoutException         If lock acquisition was not successful within the provided {@code timeout}.
     */
    TypedLockToken writeLock(K key, long timeout, TimeUnit unit)
            throws IllegalArgumentException, InterruptedException, TimeoutException;

    /**
     * Performs the unlock of an {@linkplain #writeLock(Object, long, TimeUnit) acquired write lock}.
     * <p>
     * It is expected that the provided {@code token} will be the <strong>same</strong> as that returned when
     * {@linkplain #writeLock(Object, long, TimeUnit) acquiring the lock}.
     *
     * @param key   The {@code key}, used to reference <strong>which</strong> lock should be unlocked.  Must not be
     *              {@code null}.
     * @param token The {@link LockToken} which was returned when acquiring the lock.
     *
     * @throws IllegalArgumentException     If any of the arguments are invalid.
     * @throws IllegalMonitorStateException If a lock is not held for the given {@code key} and {@link TypedLockToken}.
     */
    void unlockWriteLock(K key, TypedLockToken token)
            throws IllegalArgumentException, IllegalMonitorStateException;

    /**
     * Converts the presently held lock (indicated by the provided {@link TypedLockToken}) to a read lock.  The
     * existing lock will not be dropped by this call; however it will potentially be downgraded as a result.
     * <p>
     * It is safe to call this method with a {@code token} for an already acquired read lock.  The provided {@code
     * token} should be disregarded in favour of the returned {@link TypedLockToken} from this call.
     *
     * @param key   The {@code key}, used to reference <strong>which</strong> lock should be converted.  Must not be
     *              {@code null}.
     * @param token The {@link LockToken} which was returned when acquiring the lock.
     *
     * @return A {@link TypedLockToken} indicating successful lock conversion.
     *
     * @throws IllegalArgumentException          If any of the arguments are invalid.
     * @throws IllegalMonitorStateException      If a lock is not held for the given {@code key} and
     *                                           {@link TypedLockToken}.
     * @throws FailedLockTypeConversionException If the lock type conversion failed (the original lock will still be
     *                                           held).
     */
    TypedLockToken convertToReadLock(K key, TypedLockToken token)
            throws IllegalArgumentException, IllegalMonitorStateException,
                   FailedLockTypeConversionException;


    /**
     * Simple {@code enum} used for indicating the <strong>type</strong> of lock which has been acquired (read or
     * write).
     */
    enum LockType {
        /**
         * A {@link LockType} indicating observation only.  Multiple read locks may be concurrently held; however no
         * read lock may be held while a {@link #Write write lock} is held.
         */
        Read,

        /**
         * A {@link LockType} indicating modification.  Only a single write lock may be concurrently held; and no
         * {@link #Read read locks} may be held at the same time.
         */
        Write
    }

    /**
     * Extension of {@link com.com.lock.enterprise.LockManager.LockToken} which additionally details the
     * {@linkplain #getLockType() type} of the lock which was acquired.
     */
    interface TypedLockToken extends LockToken {

        /**
         * The {@link LockType} represented by this {@link TypedLockToken}.
         *
         * @return The {@linkplain LockType type} of lock which this {@link TypedLockToken} represents.
         */
        LockType getLockType();
    }

    /**
     * {@link Exception} type indicating that conversion of a lock from one {@linkplain LockType type} to another has
     * failed.
     */
    final class FailedLockTypeConversionException extends Exception {

        /**
         * Constructor; generates a new {@link FailedLockTypeConversionException} instance.
         *
         * @param initial The initial {@link LockType} for which the conversion failed.
         * @param target  The target {@link LockType} for which the conversion failed.
         */
        FailedLockTypeConversionException(final LockType initial, final LockType target) {
            super(String.format("Failed to convert lock of type %s to type %s", initial, target));
        }
    }
}
